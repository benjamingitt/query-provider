"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _url = _interopRequireDefault(require("url"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _utils = require("../utils");

var _gateway = _interopRequireDefault(require("../gateway"));

var _response = _interopRequireDefault(require("../response"));

var _timeoutError = require("./timeout-error");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function HTTP(request) {
  _gateway.default.apply(this, arguments);
}

HTTP.prototype = _gateway.default.extends({
  get: function get() {
    this.performRequest('get');
  },
  head: function head() {
    this.performRequest('head');
  },
  post: function post() {
    this.performRequest('post');
  },
  put: function put() {
    this.performRequest('put');
  },
  patch: function patch() {
    this.performRequest('patch');
  },
  delete: function _delete() {
    this.performRequest('delete');
  },
  performRequest: function performRequest(method) {
    var _this = this;

    var headers = {}; // eslint-disable-next-line node/no-deprecated-api

    var defaults = _url.default.parse(this.request.url());

    var requestMethod = this.shouldEmulateHTTP() ? 'post' : method;
    var body = this.prepareBody(method, headers);
    var timeout = this.request.timeout();
    this.canceled = false;

    if (body && typeof body.length === 'number') {
      headers['content-length'] = Buffer.byteLength(body);
    }

    var handler = defaults.protocol === 'https:' ? _https.default : _http.default;
    var requestParams = (0, _utils.assign)(defaults, {
      method: requestMethod,
      headers: (0, _utils.assign)(headers, this.request.headers())
    });
    var auth = this.request.auth();

    if (auth) {
      var username = auth.username || '';
      var password = auth.password || '';
      requestParams['auth'] = "".concat(username, ":").concat(password);
    }

    var httpOptions = this.options().HTTP;

    if (httpOptions.useSocketConnectionTimeout) {
      requestParams['timeout'] = timeout;
    }

    if (httpOptions.configure) {
      (0, _utils.assign)(requestParams, httpOptions.configure(requestParams));
    }

    if (httpOptions.onRequestWillStart) {
      httpOptions.onRequestWillStart(requestParams);
    }

    var httpRequest = handler.request(requestParams, function (httpResponse) {
      return _this.onResponse(httpResponse, httpOptions, requestParams);
    });
    httpRequest.on('socket', function (socket) {
      if (httpOptions.onRequestSocketAssigned) {
        httpOptions.onRequestSocketAssigned(requestParams);
      }

      socket.on('lookup', function () {
        if (httpOptions.onSocketLookup) {
          httpOptions.onSocketLookup(requestParams);
        }
      });
      socket.on('connect', function () {
        if (httpOptions.onSocketConnect) {
          httpOptions.onSocketConnect(requestParams);
        }
      });
      socket.on('secureConnect', function () {
        if (httpOptions.onSocketSecureConnect) {
          httpOptions.onSocketSecureConnect(requestParams);
        }
      });
    });
    httpRequest.on('error', function (e) {
      return _this.onError(e);
    });
    body && httpRequest.write(body);

    if (timeout) {
      if (!httpOptions.useSocketConnectionTimeout) {
        httpRequest.setTimeout(timeout);
      }

      httpRequest.on('timeout', function () {
        _this.canceled = true;
        httpRequest.abort();
        var error = (0, _timeoutError.createTimeoutError)("Timeout (".concat(timeout, "ms)"));

        _this.dispatchClientError(error.message, error);
      });
    }

    httpRequest.end();
  },
  onResponse: function onResponse(httpResponse, httpOptions, requestParams) {
    var _this2 = this;

    var rawData = [];

    if (!this.request.isBinary()) {
      httpResponse.setEncoding('utf8');
    }

    httpResponse.once('readable', function () {
      if (httpOptions.onResponseReadable) {
        httpOptions.onResponseReadable(requestParams);
      }
    });
    httpResponse.on('data', function (chunk) {
      return rawData.push(chunk);
    }).on('end', function () {
      if (_this2.canceled) {
        return;
      }

      _this2.dispatchResponse(_this2.createResponse(httpResponse, rawData));
    });
    httpResponse.on('end', function () {
      if (httpOptions.onResponseEnd) {
        httpOptions.onResponseEnd(requestParams);
      }
    });
  },
  onError: function onError(e) {
    if (this.canceled) {
      return;
    }

    this.dispatchClientError(e.message, e);
  },
  createResponse: function createResponse(httpResponse, rawData) {
    return new _response.default(this.request, httpResponse.statusCode, this.request.isBinary() ? Buffer.concat(rawData) : rawData.join(''), httpResponse.headers);
  }
});
var _default = HTTP;
exports.default = _default;
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("./utils");

var REGEXP_DYNAMIC_SEGMENT = /{([^}?]+)\??}/;
var REGEXP_OPTIONAL_DYNAMIC_SEGMENT = /\/?{([^}?]+)\?}/g;
var REGEXP_TRAILING_SLASH = /\/$/;
/**
 * @typedef Request
 * @param {MethodDescriptor} methodDescriptor
 * @param {Object} requestParams, defaults to an empty object ({})
 */

function Request(methodDescriptor, requestParams) {
  this.methodDescriptor = methodDescriptor;
  this.requestParams = requestParams || {};
}

Request.prototype = {
  /**
   * @return {Object}
   */
  params: function params() {
    var _this = this;

    var params = (0, _utils.assign)({}, this.methodDescriptor.params, this.requestParams);

    var isParam = function isParam(key) {
      return key !== _this.methodDescriptor.headersAttr && key !== _this.methodDescriptor.bodyAttr && key !== _this.methodDescriptor.authAttr && key !== _this.methodDescriptor.timeoutAttr && key !== _this.methodDescriptor.hostAttr;
    };

    return Object.keys(params).reduce(function (obj, key) {
      if (isParam(key)) {
        obj[key] = params[key];
      }

      return obj;
    }, {});
  },

  /**
   * Returns the HTTP method in lowercase
   *
   * @return {String}
   */
  method: function method() {
    return this.methodDescriptor.method.toLowerCase();
  },

  /**
   * Returns host name without trailing slash
   * Example: http://example.org
   *
   * @return {String}
   */
  host: function host() {
    var _this$methodDescripto = this.methodDescriptor,
        allowResourceHostOverride = _this$methodDescripto.allowResourceHostOverride,
        hostAttr = _this$methodDescripto.hostAttr,
        host = _this$methodDescripto.host;
    var originalHost = allowResourceHostOverride ? this.requestParams[hostAttr] || host || '' : host || '';
    return originalHost.replace(REGEXP_TRAILING_SLASH, '');
  },

  /**
   * Returns path with parameters and leading slash.
   * Example: /some/path?param1=true
   *
   * @throws {Error} if any dynamic segment is missing.
   * Example:
   * Imagine the path '/some/{name}', the error will be similar to:
   * '[Mappersmith] required parameter missing (name), "/some/{name}" cannot be resolved'
   *
   * @return {String}
   */
  path: function path() {
    var _this2 = this;

    var params = this.params();
    var path;

    if (typeof this.methodDescriptor.path === 'function') {
      path = this.methodDescriptor.path(params);
    } else {
      path = this.methodDescriptor.path;
    }

    if (path[0] !== '/') {
      path = "/".concat(path);
    } // RegExp with 'g'-flag is stateful, therefore defining it locally


    var regexp = new RegExp(REGEXP_DYNAMIC_SEGMENT, 'g');
    var dynamicSegmentKeys = [];
    var match;

    while ((match = regexp.exec(path)) !== null) {
      dynamicSegmentKeys.push(match[1]);
    }

    for (var _i = 0; _i < dynamicSegmentKeys.length; _i++) {
      var key = dynamicSegmentKeys[_i];
      var pattern = new RegExp("{".concat(key, "\\??}"), 'g');

      if (params[key] != null) {
        path = path.replace(pattern, encodeURIComponent(params[key]));
        delete params[key];
      }
    }

    path = path.replace(REGEXP_OPTIONAL_DYNAMIC_SEGMENT, '');
    var missingDynamicSegmentMatch = path.match(REGEXP_DYNAMIC_SEGMENT);

    if (missingDynamicSegmentMatch) {
      throw new Error("[Mappersmith] required parameter missing (".concat(missingDynamicSegmentMatch[1], "), \"").concat(path, "\" cannot be resolved"));
    }

    var aliasedParams = Object.keys(params).reduce(function (aliased, key) {
      var aliasedKey = _this2.methodDescriptor.queryParamAlias[key] || key;
      aliased[aliasedKey] = params[key];
      return aliased;
    }, {});
    var queryString = (0, _utils.toQueryString)(aliasedParams);

    if (queryString.length !== 0) {
      var hasQuery = path.includes('?');
      path += "".concat(hasQuery ? '&' : '?').concat(queryString);
    }

    return path;
  },

  /**
   * Returns the full URL
   * Example: http://example.org/some/path?param1=true
   *
   * @return {String}
   */
  url: function url() {
    return "".concat(this.host()).concat(this.path());
  },

  /**
   * Returns an object with the headers. Header names are converted to
   * lowercase
   *
   * @return {Object}
   */
  headers: function headers() {
    return (0, _utils.lowerCaseObjectKeys)((0, _utils.assign)({}, this.methodDescriptor.headers, this.requestParams[this.methodDescriptor.headersAttr]));
  },

  /**
   * Utility method to get a header value by name
   *
   * @param {String} name
   *
   * @return {String|Undefined}
   */
  header: function header(name) {
    return this.headers()[name.toLowerCase()];
  },
  body: function body() {
    return this.requestParams[this.methodDescriptor.bodyAttr];
  },
  auth: function auth() {
    return this.requestParams[this.methodDescriptor.authAttr];
  },
  timeout: function timeout() {
    return this.requestParams[this.methodDescriptor.timeoutAttr];
  },

  /**
   * Enhances current request returning a new Request
   * @param {Object} extras
   *   @param {Object} extras.params - it will be merged with current params
   *   @param {Object} extras.headers - it will be merged with current headers
   *   @param {String|Object} extras.body - it will replace the current body
   *   @param {Object} extras.auth - it will replace the current auth
   *   @param {Number} extras.timeout - it will replace the current timeout
   *   @param {String} extras.host - it will replace the current timeout
   */
  enhance: function enhance(extras) {
    var headerKey = this.methodDescriptor.headersAttr;
    var bodyKey = this.methodDescriptor.bodyAttr;
    var authKey = this.methodDescriptor.authAttr;
    var timeoutKey = this.methodDescriptor.timeoutAttr;
    var hostKey = this.methodDescriptor.hostAttr;
    var requestParams = (0, _utils.assign)({}, this.requestParams, extras.params);
    requestParams[headerKey] = (0, _utils.assign)({}, this.requestParams[headerKey], extras.headers);
    extras.body && (requestParams[bodyKey] = extras.body);
    extras.auth && (requestParams[authKey] = extras.auth);
    extras.timeout && (requestParams[timeoutKey] = extras.timeout);
    extras.host && (requestParams[hostKey] = extras.host);
    return new Request(this.methodDescriptor, requestParams);
  },

  /**
   * Is the request expecting a binary response?
   *
   * @return {Boolean}
   */
  isBinary: function isBinary() {
    return this.methodDescriptor.binary;
  }
};
var _default = Request;
exports.default = _default;